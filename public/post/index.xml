<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on KHIA&#39;s personal Blog</title>
    <link>http://khia.github.io/blog/post/</link>
    <description>Recent content in Posts on KHIA&#39;s personal Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 13 Nov 2014 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://khia.github.io/blog/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Consistency management in distributed settings</title>
      <link>http://khia.github.io/blog/post/consistency-management-in-distributed-settings/</link>
      <pubDate>Thu, 13 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://khia.github.io/blog/post/consistency-management-in-distributed-settings/</guid>
      <description>Consistency management in distributed settings Disclaimer I just participate in numerous design discussions related to genomu development. However all ideas and 99% of the implementation due to @yrashk. I decided to write this post to document the design of genomu inspite the fact that this great development didn&amp;rsquo;t take off.
Introduction Being a consultancy agency we had a client who have ordered a development of a backend for a system for doing sport events betting.</description>
    </item>
    
    <item>
      <title>Generating random looking IDs</title>
      <link>http://khia.github.io/blog/post/generating-random-looking-ids/</link>
      <pubDate>Thu, 13 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://khia.github.io/blog/post/generating-random-looking-ids/</guid>
      <description>Generating random looking IDs Introduction Quite often I find myself in a situation where I need a unique random looking IDs. The naive solution to this problem is to generate random IDs and memoize already issued ones to prevent duplicates. The question is can we do better?
Solution The soltution I am going to explore today is based on the use of block ciphers. Since their output is bijective (given same input IV and KEY) you will not have any collisions, unlike hashes.</description>
    </item>
    
    <item>
      <title>Protecting in-memory crypto material</title>
      <link>http://khia.github.io/blog/post/protecting-in-memory-crypto-material/</link>
      <pubDate>Thu, 13 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://khia.github.io/blog/post/protecting-in-memory-crypto-material/</guid>
      <description>Protecting in-memory crypto material Introduction Let&amp;rsquo;s say you operate a service which need to sign clients&amp;rsquo; requests. You would have to have a private key (signing key) on your server. Having keys on the server is ok as long as you fully control the server. You cannot trust the cloud provider if you use one. Even if a company you use doesn&amp;rsquo;t practice illegal access to information of their customers.</description>
    </item>
    
    <item>
      <title>Skype in docker</title>
      <link>http://khia.github.io/blog/post/skype-in-docker/</link>
      <pubDate>Thu, 13 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://khia.github.io/blog/post/skype-in-docker/</guid>
      <description>Skype in docker Introduction If you want to separate your personal life from work you would end up with two Skype accounts. However there is a problem. You cannot run multiple instances of Skype on a single computer (as single user). Here comes an idea to run Skype in the docker. Running Skype in docker is also useful for privacy sensitive individuals like myself. Since the Skype application is closed source and sends data in encrypted form.</description>
    </item>
    
  </channel>
</rss>